#include <ESP8266WiFi.h>
extern "C" {
  #include <espnow.h>
}

// MAC placa LUIS: F6 CF A2 68 68 FC
// MAC placa PEDRO: CA:2B:96:2F:46:AA
// this is the MAC Address of the remote ESP server which receives these sensor readings
uint8_t remoteMac[] = {0xF6, 0xCF, 0xA2, 0x68, 0x68, 0xFC};
//uint8_t remoteMac[] = {0x3E, 0x33, 0x33, 0x33, 0x33, 0x33};

#define WIFI_CHANNEL 4
#define SLEEP_SECS 15 * 60 // 15 minutes
#define SEND_TIMEOUT 245  // 245 millis seconds timeout 

// Tiempo para calibrarse el sensor de presencia (10-60 secs. según el datasheet)
int calibrationTime = 30;

//El momento en que el sensor emite un impulso bajo
long unsigned int lowIn; 

//Cantidad de milisegundos que el sensor tiene que ser baja 
//antes de asumir que todo el movimiento se ha detenido
long unsigned int pause = 5000; 

boolean lockLow = true;
boolean takeLowTime; 
boolean envio = false;


// keep in sync with slave struct
struct __attribute__((packed)) SENSOR_DATA {
    bool tactil;
    bool presencia = false;
} sensorData;


const int PIRPin = 14;         // pin de entrada (for PIR sensor)
const int ledPin = 16; // pin para el LED de aviso de actividad.
int pirState = LOW;           // de inicio no hay movimiento
int val = 0;                  // estado del pin


volatile boolean callbackCalled;

void gotoSleep() ;
void setup() {
  Serial.begin(115200); 
  Serial.println();
  Serial.println("Status\tTactil \tPresencia");
  
  // read sensor first before awake generates heat
  // readBME280();
  //dht.setup(5, DHTesp::DHT11); // Connect DHT sensor to GPIO 5
  pinMode(PIRPin, INPUT);
  pinMode(ledPin, OUTPUT);
  digitalWrite(PIRPin, LOW);
  
  //Dar al sensor algún tiempo para su calibrado
  Serial.print("calibrando sensor ");
  for(int i = 0; i < calibrationTime; i++){ 
   Serial.print("."); 
   delay(1000); 
  } 
  Serial.println(" echo"); 
  Serial.println("SENSOR ACTIVO"); 
  delay(50); 
  
  WiFi.mode(WIFI_STA); // Station mode for esp-now sensor node
  WiFi.disconnect();

  Serial.printf("This mac: %s, ", WiFi.macAddress().c_str()); 
  Serial.printf("target mac: %02x%02x%02x%02x%02x%02x", remoteMac[0], remoteMac[1], remoteMac[2], remoteMac[3], remoteMac[4], remoteMac[5]); 
  Serial.printf(", channel: %i\n", WIFI_CHANNEL); 

  if (esp_now_init() != 0) {
    Serial.println("*** ESP_Now init failed");
    gotoSleep();
  }

  esp_now_set_self_role(ESP_NOW_ROLE_CONTROLLER);
  esp_now_add_peer(remoteMac, ESP_NOW_ROLE_SLAVE, WIFI_CHANNEL, NULL, 0);

  esp_now_register_send_cb([](uint8_t* mac, uint8_t sendStatus) {
    Serial.printf("send_cb, send done, status = %i\n", sendStatus);
    callbackCalled = true;
  });

  callbackCalled = false;

  uint8_t bs[sizeof(sensorData)];
  memcpy(bs, &sensorData, sizeof(sensorData));
  
}

void loop() {
  if (callbackCalled || (millis() > SEND_TIMEOUT)) {
    gotoSleep();
  }
  else {
    if(digitalRead(PIRPin) == HIGH){ 
      envio=false;
      digitalWrite(ledPin, HIGH); // El LED visualiza el estado de pin de salida del sensor 
      if(lockLow){ // Se asegura que esperamos una transición a LOW antes de cualquier salida adicional: 
        lockLow = false; 

        envio=true;
        Serial.println("---"); 
        Serial.print("movimiento detectado "); 
        Serial.print(millis()/1000); 
        Serial.println(" sec"); 
        delay(1); 
      } 
      takeLowTime = true; 
    } 
    if(digitalRead(PIRPin) == LOW){ 
      envio=false;
      digitalWrite(ledPin, LOW); // El LED visualiza el estado del sensor por pin de salida 
      if(takeLowTime){ 
        lowIn = millis(); // guarda el tiempo de la transición de HIGH a LOW 
        takeLowTime = false; // asegurar que esto se hace solamente al inicio de una fase de baja 
    } 
    // Si el sensor es bajo por más de la pausa dada, 
    // suponemos que hay más movimientos que van a suceder 
    if(!lockLow && millis() - lowIn > pause){ 
       // se cerciora este bloque de código sólo se ejecuta nuevamente después
       // de que una nueva secuencia de movimiento se ha detectado
       lockLow = true; 
       Serial.print("motion ended at "); //output
       Serial.print((millis() - pause)/1000);
       Serial.println(" sec");
       delay(1);
    }
  }
    //delay(dht.getMinimumSamplingPeriod()); //Poner otro delay
    sensorData.tactil = true;
    if(digitalRead(PIRPin)==HIGH){
      sensorData.presencia = true;
    }
    else{
      sensorData.presencia = false;
    }
    //Serial.printf("presencia=%01f, tactil=%01f", sensorData.presencia, sensorData.tactil);
    Serial.print(sensorData.presencia, 1);
    Serial.print("\t\t");
    Serial.print(sensorData.tactil, 1);
    Serial.print("\t\t");
    if (envio){
      esp_now_send(remoteMac, (uint8_t *)&sensorData, sizeof(sensorData));
    }
  }
}

void gotoSleep() {
  // add some randomness to avoid collisions with multiple devices
  int sleepSecs = SLEEP_SECS + ((uint8_t)RANDOM_REG32/2); 
  Serial.printf("Up for %i ms, going to sleep for %i secs...\n", millis(), sleepSecs); 
  ESP.deepSleep(sleepSecs * 1000000, RF_NO_CAL);
}
